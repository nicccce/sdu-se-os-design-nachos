// filehdr.cc 
//	管理磁盘文件头的例程（在 UNIX 中，这被称为 i-node）。
//
//	文件头用于定位文件数据在磁盘上的存储位置。
//	我们将其实现为固定大小的指针表 -- 表中的每个条目指向
//	包含该部分文件数据的磁盘扇区（换句话说，没有间接或
//	双重间接块）。表大小被选择为使文件头足够大，以适应
//	一个磁盘扇区。
//
//      与真实系统不同，我们不在文件头中跟踪文件权限、
//	所有权、最后修改日期等。
//
//	文件头可以通过两种方式初始化：
//	   对于新文件，通过修改内存中的数据结构以指向
//	     新分配的数据块
//	   对于磁盘上已有的文件，通过从磁盘读取文件头
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"

#include "system.h"
#include "filehdr.h"

// 文件头结构说明：
// 1. 类似UNIX的i-node，但结构更简单
// 2. 固定大小：恰好占用一个磁盘扇区(通常128字节)
// 3. 直接指针：只使用直接指针，无间接指针，限制文件大小
// 4. 简化信息：不包含权限、时间戳、所有者等元数据
//
// 文件头布局：
// +------------------+
// | numBytes (4字节) |  // 文件总字节数
// +------------------+
// | numSectors(4字节) |  // 文件占用的扇区数
// +------------------+
// | dataSectors[0]   |  // 数据块扇区号0
// +------------------+
// | dataSectors[1]   |  // 数据块扇区号1
// +------------------+
// | ...              |  // 更多数据块扇区号
// +------------------+
// | dataSectors[n]   |  // 最后一个数据块扇区号
// +------------------+
//
// 计算公式：
// NumDirect = (SectorSize - 2*sizeof(int)) / sizeof(int)
// MaxFileSize = NumDirect * SectorSize

//----------------------------------------------------------------------
// FileHeader::Allocate
// 	为新创建的文件初始化一个新的文件头。
//	从空闲磁盘块的位图中为文件分配数据块。
//	如果没有足够的空闲块来容纳新文件，返回 FALSE。
//
//	"freeMap" 是空闲磁盘扇区的位图
//	"fileSize" 是要创建的文件大小(以字节为单位)
//
//	实现逻辑：
//	1. 计算文件需要的扇区数(向上取整)
//	2. 检查是否有足够的空闲扇区
//	3. 为每个数据块分配一个扇区号
//	4. 记录文件大小和扇区数信息
//
//	关键点：
//	- 使用divRoundUp向上取整，确保有足够空间
//	- 连续分配扇区，但不保证物理连续
//	- 只分配数据块，文件头扇区由调用者分配
//	- 空间不足时返回FALSE，不进行部分分配
//
//	返回值：
//	- TRUE：分配成功
//	- FALSE：空间不足，分配失败
//----------------------------------------------------------------------

bool
FileHeader::Allocate(BitMap *freeMap, int fileSize)
{ 
    // 记录文件总字节数
    numBytes = fileSize;
    
    // 计算需要的扇区数(向上取整)
    // 例如：150字节的文件需要2个扇区(假设扇区大小128字节)
    numSectors  = divRoundUp(fileSize, SectorSize);
    
    // 检查空闲空间是否足够
    if (freeMap->NumClear() < numSectors)
	return FALSE;		// 空间不足，分配失败

    // 为每个数据块分配一个扇区号
    for (int i = 0; i < numSectors; i++)
	dataSectors[i] = freeMap->Find();  // 查找并标记一个空闲扇区
	
    return TRUE;  // 分配成功
}

//----------------------------------------------------------------------
// FileHeader::Deallocate
// 	释放为该文件数据块分配的所有空间。
//
//	"freeMap" 是空闲磁盘扇区的位图
//
//	实现逻辑：
//	1. 遍历文件占用的所有扇区
//	2. 确保每个扇区确实被标记为已使用
//	3. 将每个扇区标记为空闲，释放空间
//
//	关键点：
//	- 使用ASSERT确保扇区确实被占用，检测数据一致性
//	- 只释放数据块，不释放文件头本身
//	- 文件头的释放由调用者(如FileSystem::Remove)负责
//	- 释放后的扇区可以被其他文件使用
//
//	使用场景：
//	- 文件被删除时
//	- 文件截断时(如果Nachos支持的话)
//	- 文件系统检查和修复时
//----------------------------------------------------------------------

void 
FileHeader::Deallocate(BitMap *freeMap)
{
    // 遍历文件占用的所有数据扇区
    for (int i = 0; i < numSectors; i++) {
	// 断言检查：确保扇区确实被标记为已使用
	// 如果失败，说明文件系统数据结构可能损坏
	ASSERT(freeMap->Test((int) dataSectors[i]));  
	
	// 将扇区标记为空闲，释放空间
	freeMap->Clear((int) dataSectors[i]);
    }
}

//----------------------------------------------------------------------
// FileHeader::FetchFrom
// 	从磁盘获取文件头的内容。
//
//	"sector" 是包含文件头的磁盘扇区
//
//	实现逻辑：
//	1. 使用同步磁盘接口读取指定扇区
//	2. 将读取的数据直接复制到当前FileHeader对象
//	3. 整个文件头结构作为一个完整的扇区被读取
//
//	关键点：
//	- 直接内存拷贝，效率高
//	- 文件头恰好占用一个扇区，简化了读取操作
//	- 使用synchDisk确保线程安全的磁盘访问
//	- 读取后，文件头的所有字段都被正确初始化
//
//	使用场景：
//	- 打开文件时读取文件头
//	- 文件系统初始化时加载系统文件头
//	- 目录操作时读取文件头
//
//	注意：调用此函数前，FileHeader对象必须已创建
//----------------------------------------------------------------------

void
FileHeader::FetchFrom(int sector)
{
    // 从指定扇区读取整个文件头到当前对象
    // 参数：扇区号，目标缓冲区(this指向当前FileHeader对象)
    synchDisk->ReadSector(sector, (char *)this);
}

//----------------------------------------------------------------------
// FileHeader::WriteBack
// 	将文件头的修改内容写回磁盘。
//
//	"sector" 是要包含文件头的磁盘扇区
//
//	实现逻辑：
//	1. 使用同步磁盘接口写入指定扇区
//	2. 将当前FileHeader对象的内容完整写入磁盘
//	3. 整个文件头结构作为一个完整的扇区被写入
//
//	关键点：
//	- 直接内存拷贝，效率高
//	- 文件头恰好占用一个扇区，简化了写入操作
//	- 使用synchDisk确保线程安全的磁盘访问
//	- 写入是原子的，要么成功要么失败
//
//	使用场景：
//	- 创建文件后写入文件头
//	- 修改文件大小后更新文件头
//	- 文件系统关闭前保存状态
//
//	注意：写入操作会覆盖整个扇区的内容
//----------------------------------------------------------------------

void
FileHeader::WriteBack(int sector)
{
    // 将当前文件头对象写入指定扇区
    // 参数：扇区号，源缓冲区(this指向当前FileHeader对象)
    synchDisk->WriteSector(sector, (char *)this); 
}

//----------------------------------------------------------------------
// FileHeader::ByteToSector
// 	返回哪个磁盘扇区存储文件中的特定字节。
//      这本质上是从虚拟地址（文件中的偏移量）
//	到物理地址（存储偏移量数据的扇区）的转换。
//
//	"offset" 是问题字节在文件中的位置
//
//	实现逻辑：
//	1. 计算偏移量位于哪个扇区
//	2. 返回对应的数据扇区号
//
//	关键点：
//	- 使用整数除法计算扇区索引
//	- 扇区大小通常为128字节
//	- 例如：offset=200，SectorSize=128，则返回dataSectors[1]
//	- 这是文件系统地址转换的核心函数
//
//	计算公式：
//	sectorIndex = offset / SectorSize
//	return dataSectors[sectorIndex]
//
//	使用场景：
//	- 文件读写操作中定位数据块
//	- OpenFile类的ReadAt和WriteAt方法
//	- 文件内容访问和修改
//
//	注意：调用者需确保offset在文件有效范围内
//----------------------------------------------------------------------

int
FileHeader::ByteToSector(int offset)
{
    // 计算偏移量对应的扇区索引，并返回对应的数据扇区号
    // 例如：字节0-127在扇区0，字节128-255在扇区1，以此类推
    return(dataSectors[offset / SectorSize]);
}

//----------------------------------------------------------------------
// FileHeader::FileLength
// 	返回文件中的字节数。
//
//	实现逻辑：
//	直接返回numBytes字段的值
//
//	关键点：
//	- numBytes在Allocate()时设置
//	- 包含文件的实际数据大小，不是分配的磁盘空间
//	- 可能小于实际分配的扇区数×扇区大小
//
//	使用场景：
//	- 文件大小查询
//	- 文件读写边界检查
//	- 目录列表显示文件大小
//	- 文件系统统计信息收集
//
//	注意：返回的是逻辑大小，不是物理占用空间
//----------------------------------------------------------------------

int
FileHeader::FileLength()
{
    return numBytes;  // 返回文件的实际字节数
}

//----------------------------------------------------------------------
// FileHeader::Print
// 打印文件头的内容，以及文件头指向的所有数据块的内容。
//
// 实现逻辑：
// 1. 打印文件头基本信息(文件大小、扇区列表)
// 2. 逐个扇区读取文件数据
// 3. 打印每个扇区的内容(可打印字符直接显示，其他用十六进制)
// 4. 释放临时缓冲区
//
// 关键点：
// - 产生大量磁盘I/O操作，仅用于调试
// - 可打印字符(ASCII 32-126)直接显示
// - 非打印字符以十六进制格式显示(如\n显示为\x0a)
// - 只显示文件的实际内容，不显示扇区末尾的未使用空间
//
// 输出示例：
// FileHeader contents.  File size: 150.  File blocks:
// 10 11 
// File contents:
// This is the first line of the file.\n
// And this is the second line.\x00\x00\x00...
//
// 使用场景：
// - 文件系统调试
// - 检查文件完整性
// - 分析文件内容
// - 教学演示文件系统工作原理
//
// 注意：此函数会读取整个文件内容，对大文件可能很慢
//----------------------------------------------------------------------

void
FileHeader::Print()
{
    int i, j, k;
    char *data = new char[SectorSize];  // 临时缓冲区，用于存储一个扇区的数据

    // 打印文件头基本信息
    printf("FileHeader contents.  File size: %d.  File blocks:\n", numBytes);
    
    // 打印文件占用的所有扇区号
    for (i = 0; i < numSectors; i++)
	printf("%d ", dataSectors[i]);
    
    printf("\nFile contents:\n");
    
    // 逐个扇区读取并打印文件内容
    for (i = k = 0; i < numSectors; i++) {
	// 读取一个扇区的数据
	synchDisk->ReadSector(dataSectors[i], data);
	
	// 打印扇区内容(只显示文件实际使用的字节)
        for (j = 0; (j < SectorSize) && (k < numBytes); j++, k++) {
	    // 检查是否为可打印字符(ASCII 32-126)
	    if ('\040' <= data[j] && data[j] <= '\176')   // isprint(data[j])
		printf("%c", data[j]);  // 直接显示可打印字符
            else
		printf("\\%x", (unsigned char)data[j]);  // 非打印字符用十六进制显示
	}
        printf("\n");  // 每个扇区结束后换行
    }
    
    delete [] data;  // 释放临时缓冲区
}