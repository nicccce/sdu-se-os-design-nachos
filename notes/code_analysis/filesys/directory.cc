// directory.cc 
//	管理文件名目录的例程。
//
//	目录是一个固定长度条目的表；每个条目代表一个单独的文件，
//	包含文件名和文件头在磁盘上的位置。每个目录条目的固定大小
//	意味着我们对文件名有固定最大大小的限制。
//
//	构造函数初始化一个特定大小的空目录；
//	我们使用 ReadFrom/WriteBack 从磁盘获取目录内容，
//	并将任何修改写回磁盘。
//
//	另外，这个实现有一个限制，即目录的大小不能扩展。
//	换句话说，一旦目录中的所有条目都被使用，就不能再创建更多文件。
//	修复这个问题是作业的一部分。
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "utility.h"
#include "filehdr.h"
#include "directory.h"

// 全局常量定义
// 文件名最大长度（包括结尾的'\0'）
#define FileNameMaxLen 9

//----------------------------------------------------------------------
// Directory::Directory
// 	初始化一个目录；最初，目录是完全空的。如果正在格式化磁盘，
//	空目录就是我们所需要的，但否则，我们需要调用 FetchFrom 
//	以便从磁盘初始化它。
//
//	"size" 是目录中的条目数
//	
//	实现逻辑：
//	1. 分配指定大小的目录条目数组
//	2. 记录目录大小
//	3. 将所有条目标记为未使用状态
//	
//	关键数据结构：
//	- table: DirectoryEntry数组，存储目录条目
//	- tableSize: 目录的最大容量
//	
//	每个DirectoryEntry包含：
//	- inUse: 布尔值，表示该条目是否被使用
//	- sector: 整数，存储文件头的磁盘扇区号
//	- name: 字符数组，存储文件名
//----------------------------------------------------------------------

Directory::Directory(int size)
{
    // 分配目录条目数组，每个条目代表一个文件
    table = new DirectoryEntry[size];
    // 记录目录的最大容量
    tableSize = size;
    // 初始化所有条目为未使用状态
    for (int i = 0; i < tableSize; i++)
	table[i].inUse = FALSE;
}

//----------------------------------------------------------------------
// Directory::~Directory
// 	释放目录数据结构。
//
//	实现逻辑：
//	1. 释放目录条目数组占用的内存
//	2. 防止内存泄漏
//	
//	注意：这里使用delete[]而不是delete，因为table是通过new[]分配的数组
//----------------------------------------------------------------------

Directory::~Directory()
{ 
    // 释放目录条目数组，防止内存泄漏
    delete [] table;
} 

//----------------------------------------------------------------------
// Directory::FetchFrom
// 	从磁盘读取目录的内容。
//
//	"file" -- 包含目录内容的文件
//
//	实现逻辑：
//	1. 从文件的起始位置(偏移量0)读取目录数据
//	2. 将读取的数据直接复制到目录条目数组中
//	3. 目录数据大小 = 条目数 × 每个条目的大小
//	
//	关键点：
//	- 目录在磁盘上作为普通文件存储
//	- 读取操作从偏移量0开始，读取整个目录
//	- 直接内存拷贝，提高效率
//	
//	使用场景：
//	- 文件系统初始化时加载根目录
//	- 目录操作前从磁盘获取最新内容
//----------------------------------------------------------------------

void
Directory::FetchFrom(OpenFile *file)
{
    // 从文件起始位置读取整个目录数据到内存中的table数组
    // 参数：目标缓冲区、读取字节数、文件偏移量
    (void) file->ReadAt((char *)table, tableSize * sizeof(DirectoryEntry), 0);
}

//----------------------------------------------------------------------
// Directory::WriteBack
// 	将目录的任何修改写回磁盘
//
//	"file" -- 包含新目录内容的文件
//
//	实现逻辑：
//	1. 将内存中的目录条目数组写入文件
//	2. 从文件的起始位置(偏移量0)开始写入
//	3. 写入整个目录数据，确保一致性
//	
//	关键点：
//	- 目录修改后必须调用此函数持久化到磁盘
//	- 写入操作覆盖整个目录文件
//	- 确保目录在磁盘和内存中的一致性
//	
//	使用场景：
//	- 创建文件后更新目录
//	- 删除文件后更新目录
//	- 文件系统关闭前保存目录状态
//----------------------------------------------------------------------

void
Directory::WriteBack(OpenFile *file)
{
    // 将内存中的整个目录数组写回文件的起始位置
    // 参数：源缓冲区、写入字节数、文件偏移量
    (void) file->WriteAt((char *)table, tableSize * sizeof(DirectoryEntry), 0);
}

//----------------------------------------------------------------------
// Directory::FindIndex
// 	在目录中查找文件名，并返回它在目录条目表中的位置。
//	如果名称不在目录中，返回 -1。
//
//	"name" -- 要查找的文件名
//
//	实现逻辑：
//	1. 遍历目录中的所有条目
//	2. 检查每个条目是否被使用(inUse == TRUE)
//	3. 比较文件名(最多比较FileNameMaxLen个字符)
//	4. 找到匹配项返回索引，否则返回-1
//	
//	关键点：
//	- 使用strncmp而非strcmp，限制比较长度
//	- 只检查已使用的条目，跳过空闲条目
//	- 线性搜索，时间复杂度O(n)
//	
//	返回值：
//	- 成功：返回条目在数组中的索引(0到tableSize-1)
//	- 失败：返回-1，表示文件不存在
//----------------------------------------------------------------------

int
Directory::FindIndex(char *name)
{
    // 线性搜索整个目录表
    for (int i = 0; i < tableSize; i++) {
        // 只检查已使用的条目，并比较文件名
        if (table[i].inUse && !strncmp(table[i].name, name, FileNameMaxLen))
	    return i;  // 找到匹配项，返回索引
    }
    return -1;		// 未找到文件
}

//----------------------------------------------------------------------
// Directory::Find
// 	在目录中查找文件名，并返回存储文件头的磁盘扇区号。
//	如果名称不在目录中，返回 -1。
//
//	"name" -- 要查找的文件名
//
//	实现逻辑：
//	1. 调用FindIndex查找文件在目录中的位置
//	2. 如果找到，返回对应的文件头扇区号
//	3. 如果未找到，返回-1
//	
//	关键点：
//	- 复用FindIndex函数，避免代码重复
//	- 返回的是文件头所在的扇区号，而非目录条目索引
//	- 扇区号是文件系统定位文件的关键信息
//	
//	返回值：
//	- 成功：返回文件头所在的磁盘扇区号
//	- 失败：返回-1，表示文件不存在
//	
//	使用场景：
//	- 打开文件时定位文件头
//	- 删除文件时获取文件头位置
//	- 文件操作前的存在性检查
//----------------------------------------------------------------------

int
Directory::Find(char *name)
{
    // 首先查找文件在目录表中的索引位置
    int i = FindIndex(name);

    if (i != -1)
	return table[i].sector;  // 返回文件头所在的扇区号
    return -1;  // 文件不存在
}

//----------------------------------------------------------------------
// Directory::Add
// 	向目录中添加一个文件。如果成功返回 TRUE；
//	如果文件名已在目录中，或者目录已完全满，
//	没有更多空间用于额外的文件名，则返回 FALSE。
//
//	"name" -- 正在添加的文件的名称
//	"newSector" -- 包含添加文件头的磁盘扇区
//
//	实现逻辑：
//	1. 检查文件是否已存在，避免重复
//	2. 查找第一个空闲的目录条目
//	3. 填充目录条目的各个字段
//	4. 标记条目为已使用状态
//	
//	关键点：
//	- 使用strncpy确保不会溢出文件名缓冲区
//	- 线性搜索第一个空闲位置
//	- 目录满时返回FALSE，这是Nachos的限制
//	
//	返回值：
//	- TRUE：文件成功添加到目录
//	- FALSE：文件已存在或目录已满
//	
//	使用场景：
//	- 创建新文件时更新目录
//	- 文件系统格式化时添加系统文件
//	
//	注意：Nachos目录大小固定，不支持动态扩展
//----------------------------------------------------------------------

bool
Directory::Add(char *name, int newSector)
{ 
    // 检查文件是否已存在
    if (FindIndex(name) != -1)
	return FALSE;  // 文件已存在，添加失败

    // 查找第一个空闲的目录条目
    for (int i = 0; i < tableSize; i++) {
        if (!table[i].inUse) {  // 找到空闲条目
            // 填充目录条目信息
            table[i].inUse = TRUE;  // 标记为已使用
            strncpy(table[i].name, name, FileNameMaxLen);  // 复制文件名
            table[i].sector = newSector;  // 设置文件头扇区号
            return TRUE;  // 添加成功
	}
    }
    return FALSE;	// 目录已满，无法添加更多文件
}

//----------------------------------------------------------------------
// Directory::Remove
// 	从目录中删除文件名。如果成功返回 TRUE；
//	如果文件不在目录中，返回 FALSE。
//
//	"name" -- 要删除的文件名
//
//	实现逻辑：
//	1. 查找文件在目录中的位置
//	2. 如果找到，将条目标记为未使用
//	3. 注意：这里只是逻辑删除，不释放文件头和数据块
//	
//	关键点：
//	- 只是将inUse标志设为FALSE，不清理其他字段
//	- 实际的磁盘空间释放由文件系统负责
//	- 目录项的空间被重用，但不会压缩目录
//	
//	返回值：
//	- TRUE：文件成功从目录中移除
//	- FALSE：文件不存在
//	
//	使用场景：
//	- 删除文件时的目录更新
//	- 文件系统维护操作
//	
//	注意：此函数只处理目录部分，文件头和数据块的释放
//	      需要在更高层(如FileSystem::Remove)中处理
//----------------------------------------------------------------------

bool
Directory::Remove(char *name)
{ 
    // 查找文件在目录中的位置
    int i = FindIndex(name);

    if (i == -1)
	return FALSE; 		// 文件不存在，删除失败
	
    // 逻辑删除：将条目标记为未使用
    // 注意：不清理name和sector字段，因为条目会被重用
    table[i].inUse = FALSE;
    return TRUE;	// 删除成功
}

//----------------------------------------------------------------------
// Directory::List
// 列出目录中的所有文件名。
//
//	实现逻辑：
//	1. 遍历目录中的所有条目
//	2. 只打印已使用条目的文件名
//	3. 每个文件名占一行
//	
//	关键点：
//	- 只显示有效文件，跳过已删除的条目
//	- 输出格式简单，每行一个文件名
//	- 不显示文件大小、扇区号等其他信息
//	
//	使用场景：
//	- 用户查看目录内容
//	- 文件系统调试
//	- 命令行ls命令的实现基础
//	
//	输出示例：
//	file1.txt
//	test.c
//	nachos
//----------------------------------------------------------------------

void
Directory::List()
{
   // 遍历整个目录表
   for (int i = 0; i < tableSize; i++) {
	// 只处理已使用的条目
	if (table[i].inUse)
	    printf("%s\n", table[i].name);  // 打印文件名并换行
   }
}

//----------------------------------------------------------------------
// Directory::Print
// 列出目录中的所有文件名、它们的 FileHeader 位置，
// 以及每个文件的内容。用于调试。
//
// 实现逻辑：
// 1. 创建一个临时的FileHeader对象
// 2. 遍历目录中的所有条目
// 3. 对每个已使用的条目：
//    a. 打印文件名和扇区号
//    b. 从磁盘读取文件头
//    c. 调用FileHeader::Print()打印文件详细信息
// 4. 释放临时FileHeader对象
// 	
// 关键点：
// - 提供比List()更详细的信息
// - 包括文件头扇区号和文件内容
// - 主要用于调试和文件系统分析
// - 会产生大量磁盘I/O操作
// 	
// 输出示例：
// Directory contents:
// Name: test.txt, Sector: 5
// FileHeader contents.  File size: 128.  File blocks:
// 10 11 12 
// File contents:
// This is test file content...
// 	
// Name: prog.c, Sector: 8
// ...
//
// 使用场景：
// - 文件系统调试
// - 检查文件完整性
// - 分析文件系统状态
//----------------------------------------------------------------------

void
Directory::Print()
{ 
    // 创建临时FileHeader对象用于读取文件信息
    FileHeader *hdr = new FileHeader;

    printf("Directory contents:\n");
    // 遍历整个目录表
    for (int i = 0; i < tableSize; i++) {
	// 只处理已使用的条目
	if (table[i].inUse) {
	    // 打印文件基本信息
	    printf("Name: %s, Sector: %d\n", table[i].name, table[i].sector);
	    
	    // 从磁盘读取文件头并打印详细信息
	    hdr->FetchFrom(table[i].sector);  // 读取文件头
	    hdr->Print();                     // 打印文件头和内容
	}
    }
    printf("\n");
    delete hdr;  // 释放临时对象
}