# 实验3 使用信号量解决N线程屏障问题

## 实验内容
使用操作系统信号量机制，编写程序解决N线程屏障问题。包括：

## 1. Nachos信号量实现分析

Nachos中的信号量是一种经典的同步原语，用于解决多线程并发问题。信号量的核心思想是通过一个非负整数值来控制对共享资源的访问，提供P()和V()两个原子操作。P()操作（也称为wait或down）用于等待信号量值大于0，然后将其减1；V()操作（也称为signal或up）用于将信号量值加1，并可能唤醒等待的线程。

在Nachos的实现中，信号量由Semaphore类定义，其核心数据成员包括信号量名称、当前值和等待队列。信号量名称用于调试目的，当前值始终为非负整数，等待队列则存放因P()操作而阻塞的线程。【截图位置：synch.h文件中Semaphore类的定义部分】

P()操作是信号量中最复杂的操作，其实现需要解决原子性和线程阻塞两个关键问题。Nachos通过关闭中断来保证操作的原子性，这是基于单处理器环境的假设。P()操作的执行流程首先关闭中断确保整个操作的原子性，然后检查信号量值是否为0，如果为0表示资源不可用，就将当前线程加入等待队列并调用Sleep()使其阻塞；如果资源可用，则将信号量值减1表示占用了一个资源单位，最后恢复中断状态使其他线程可以继续执行。【截图位置：synch.cc文件中Semaphore::P()函数的实现】

这种实现方式的关键在于通过`interrupt->SetLevel(IntOff)`关闭中断确保在检查信号量值和可能阻塞之间不会有其他线程干扰，调用`currentThread->Sleep()`使线程放弃CPU进入阻塞状态，以及使用List数据结构管理等待的线程，支持FIFO调度策略。

V()操作相对简单，主要负责释放资源并可能唤醒等待的线程。其实现同样需要保证原子性，但逻辑更为直接。V()操作首先关闭中断保证原子性，然后从等待队列中取出一个线程（如果有的话），如果有等待线程就将其状态设置为就绪并放入就绪队列，接着将信号量值加1表示释放了一个资源单位，最后恢复中断状态。【截图位置：synch.cc文件中Semaphore::V()函数的实现】

V()操作的实现特点包括每次只唤醒一个等待线程遵循公平性原则，先唤醒线程再增加信号量值确保被唤醒的线程能够立即获得资源，以及通过`scheduler->ReadyToRun(thread)`将被唤醒的线程放入就绪队列。

Nachos提供了三种主要的同步原语：信号量、锁(Lock)和条件变量(Condition)。其中，信号量是最基础的同步机制，锁和条件变量都可以基于信号量实现。锁的实现直接使用了信号量【截图位置：synch.cc文件中Lock类的构造函数】，这种设计体现了同步原语的层次关系：信号量是最基础的同步机制，可以解决各种同步问题；锁是基于信号量实现的互斥机制，增加了所有权概念；条件变量用于复杂的线程同步场景，通常与锁配合使用。

## 2. Nachos中并发线程的创建与运行机制

在Nachos中，线程的创建是一个精心设计的过程，涉及内存分配、栈初始化和调度器集成等多个环节。线程创建的核心是Thread类的Fork()方法，它实现了从线程对象到可执行实体的转换。线程创建的基本流程包括创建Thread对象初始化线程控制块，调用Fork()方法指定线程要执行的函数和参数，在Fork()内部调用StackAllocate()分配并初始化线程栈，最后将线程放入就绪队列等待调度器调度。【截图位置：thread.cc文件中Thread::Fork()函数的实现】

StackAllocate()是线程创建过程中最关键的部分，它负责设置线程开始执行时的寄存器状态。这个过程模拟了真实操作系统中线程上下文的初始化。栈初始化的核心步骤包括为线程分配栈空间（大小由StackSize定义），在栈顶设置栈溢出检测标记(STACK_FENCEPOST)，以及设置线程开始执行时的寄存器状态。寄存器状态的设置包括PC寄存器指向ThreadRoot函数（线程入口点），启动PC指向InterruptEnable函数（启用中断），初始PC指向用户指定的函数，函数参数传递给用户函数的参数，完成PC指向ThreadFinish函数（线程结束处理）。【截图位置：thread.cc文件中StackAllocate()函数的实现】

这种设计确保了线程被调度时能够按照预定的流程执行：首先执行ThreadRoot函数进行线程初始化，然后调用InterruptEnable启用中断，接着执行用户指定的函数，最后调用ThreadFinish进行清理工作。

Nachos的线程调度基于优先级队列（在实验2中已实现），调度器负责从就绪队列中选择下一个要运行的线程。线程的并发执行实际上是通过快速的上下文切换实现的。线程调度的关键机制包括调度器维护多个优先级队列按优先级顺序调度线程，通过SWITCH汇编函数实现线程间的快速切换，以及通过定时器中断实现时间片轮转调度。【截图位置：scheduler.cc文件中ReadyToRun()和FindNextToRun()函数的实现】

并发执行的实现依赖于中断系统，定时器中断定期触发强制当前线程让出CPU，中断处理函数检查是否有其他就绪线程需要执行，如果有则通过YieldOnReturn标记在返回时进行线程切换。

Nachos中的线程并发有两种实现方式：真正的并发执行和线程主动让出CPU。这两种方式在实现机制和执行效果上有显著差异。真正的并发执行由定时器中断驱动，不依赖线程的主动行为，线程可能在执行任意指令时被抢占，通过-rs选项可以引入随机性模拟真实环境中的调度不确定性，适用于测试同步机制的正确性和鲁棒性。而线程主动让出CPU则是线程通过调用Yield()方法主动放弃CPU，让出的时机由线程代码控制具有确定性，适用于演示特定调度场景和同步机制，但不能真实模拟多线程环境中的竞争条件。【截图位置：thread.cc文件中Thread::Yield()函数的实现】

在实验3中，我们需要使用真正的并发执行来测试N线程屏障的实现，这样才能发现多线程同步中的潜在问题。通过使用不同的随机数种子(`./nachos -rs seed`)，可以模拟各种线程调度顺序，全面测试屏障实现的正确性。

中断系统是Nachos实现真正并发的关键基础设施，它不仅负责处理硬件中断模拟，还提供了线程调度的时机。中断系统的核心功能包括通过SystemTick推进系统时间，维护待处理中断队列按时间顺序处理中断，以及在适当时机触发线程切换。【截图位置：interrupt.cc文件中CheckIfDue()和OneTick()函数的实现】

定时器中断是并发控制的核心，每隔固定时间间隔（默认100个时钟周期）触发一次中断，中断处理函数可能标记需要在返回时进行线程切换，这种机制确保了没有线程能够无限期占用CPU。通过中断系统，Nachos实现了类似真实操作系统的抢占式调度，为测试复杂的同步机制（如N线程屏障）提供了真实的环境。